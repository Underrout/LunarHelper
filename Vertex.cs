using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace LunarHelper
{
    // Base Vertex class
    class Vertex
    {

    }

    // Vertex representing an arbitrary file
    // Generated by constructs like incsrc <macro_variable> which 
    // cannot neatly be resolved to a file, but could point to just 
    // about any file
    class ArbitraryFileVertex : Vertex
    {

    }

    // Vertex representing a file that was not found at the 
    // specified file path
    class MissingFileVertex : FileVertex
    {
        public MissingFileVertex(string file_path) : base(file_path)
        {

        }
    }

    // Vertex representing a file generated by some tool or process
    // These files are not hashed, since they change all the time, but
    // dependencies on them should still be recorded
    class GeneratedFileVertex : FileVertex
    {
        public GeneratedFileVertex(string file_path) : base(file_path)
        {

        }
    }

    // Vertex class representing the root of a tool's dependencies, notably not bound to 
    // any specific file, just serves to represent the abstract idea of a tool as a unit
    // rather than a collection of files
    class ToolRootVertex : Vertex
    {
        public enum Tool
        {
            Amk,
            Pixi,
            Gps,
            UberAsm
        }

        public readonly Tool type;

        public ToolRootVertex(Tool type)
        {
            this.type = type;
        }
    }

    // Vertex class representing the root of a patch file declared for asar insertion
    class PatchRootVertex : HashFileVertex
    {
        public readonly string normalized_relative_patch_path;

        public PatchRootVertex(string user_specified_patch_path) : base(user_specified_patch_path)
        {
            normalized_relative_patch_path = user_specified_patch_path.Replace('/', '\\')
                .TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar).ToLowerInvariant();
        }
    }

    class NoUnderlyingFileException : Exception
    {
        public NoUnderlyingFileException() 
        { 

        }

        public NoUnderlyingFileException(string file_path) : base($"No underlying file found for path \"{file_path}\"")
        {

        }
    }

    // Vertex class representing a file somewhere within the filesystem
    class FileVertex : Vertex
    {
        public readonly string normalized_file_path;

        public FileVertex(string file_path)
        {
            normalized_file_path = Util.NormalizePath(file_path);
        }

        public override int GetHashCode()
        {
            return normalized_file_path.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }
            else
            {
                if (obj is FileVertex)
                {
                    FileVertex other = (FileVertex)obj;
                    return this.normalized_file_path == other.normalized_file_path;
                }
                else
                {
                    return false;
                }
            }
        }
    }

    class HashFileVertex : FileVertex
    {
        public readonly string hash;

        public HashFileVertex(string file_path) : base(file_path)
        {
            if (!File.Exists(normalized_file_path))
            {
                throw new NoUnderlyingFileException(normalized_file_path);
            }

            this.hash = Report.HashFile(normalized_file_path);
        }
    }
}
