using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace LunarHelper
{
    // Base Vertex class
    class Vertex
    {

    }

    // Vertex representing an arbitrary file
    // Generated by constructs like incsrc <macro_variable> which 
    // cannot neatly be resolved to a file, but could point to just 
    // about any file
    class ArbitraryFileVertex : Vertex
    {

    }

    // Vertex representing a file or directory that was not found at the 
    // specified file path
    class MissingFileOrDirectoryVertex : FileVertex
    {
        public MissingFileOrDirectoryVertex(Uri uri) : base(uri)
        {

        }
    }

    // Vertex representing a file generated by some tool or process
    // These files are not hashed, since they change all the time, but
    // dependencies on them should still be recorded
    class GeneratedFileVertex : FileVertex
    {
        public GeneratedFileVertex(Uri uri) : base(uri)
        {

        }
    }

    // Vertex class representing the root of a tool's dependencies, notably not bound to 
    // any specific file, just serves to represent the abstract idea of a tool as a unit
    // rather than a collection of files
    class ToolRootVertex : Vertex
    {
        public enum Tool
        {
            Amk,
            Pixi,
            Gps,
            UberAsm
        }

        public readonly Tool type;

        public ToolRootVertex(Tool type)
        {
            this.type = type;
        }
    }

    // Vertex class representing the root of a patch file declared for asar insertion
    class PatchRootVertex : HashFileVertex
    {
        public readonly string normalized_relative_patch_path;

        public PatchRootVertex(string user_specified_patch_path) : base(Util.GetUri(user_specified_patch_path))
        {
            normalized_relative_patch_path = user_specified_patch_path.Replace('/', '\\')
                .TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar).ToLowerInvariant();
        }
    }

    class NoUnderlyingFileException : Exception
    {
        public NoUnderlyingFileException()
        {

        }

        public NoUnderlyingFileException(string file_path) : base($"No underlying file found for path \"{file_path}\"")
        {

        }
    }

    // Vertex class representing a file somewhere within the filesystem
    class FileVertex : Vertex
    {
        public readonly Uri uri;

        public FileVertex(Uri uri)
        {
            this.uri = uri;
        }

        public override int GetHashCode()
        {
            return uri.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }
            else
            {
                if (obj is FileVertex)
                {
                    FileVertex other = (FileVertex)obj;
                    return this.uri == other.uri;
                }
                else
                {
                    return false;
                }
            }
        }
    }

    // vertex that includes a hash of a file's content as well as
    // its (case-sensitive) file name including its extension
    class HashFileNameVertex : HashFileVertex
    {
        public readonly string file_name;

        public HashFileNameVertex(Uri uri) : base(uri)
        {
            file_name = Path.GetFileName(uri.LocalPath);
        }
    }

    // vertex that includes a hash of a file's content
    class HashFileVertex : FileVertex
    {
        public readonly string hash;

        public HashFileVertex(Uri uri) : base(uri)
        {
            if (!File.Exists(uri.LocalPath))
            {
                throw new NoUnderlyingFileException(uri.LocalPath);
            }

            this.hash = Report.HashFile(uri.LocalPath);
        }
    }
}
